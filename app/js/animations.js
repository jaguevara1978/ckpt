$( function( ) {    'use strict';//    var image = $( "#wanted-monkey" )[ 0 ];//     TweenMax.fromTo( image, 2, { webkitFilter: "grayscale( 0 )", filter: "grayscale( 0 )" }, { webkitFilter: "grayscale( 1 )", filter: "grayscale( 1 )" } );//    TweenMax.set( image, { webkitFilter: "grayscale( 0 )", filter: "grayscale( 0 )" } );function randomBetween( min,max ) {    return Math.floor( Math.random( ) * ( max-min + 1 ) + min );}var imgBottom = document.getElementById( 'img_bottom' );var timeLine = new TimelineMax( { onComplete:meanMonkey } );function meanMonkey( ) {    var topStart = 0;    var topEnd = 0;    var rightStart = 0;    var rightEnd = 0;    var rotate = 0;    var position = randomBetween( 1, 8 ); //1-Top, 2-Right, 3-Bottom, 4-Left, 5-TopRight, 6-BottomRight, 7-Bottom-Left, 8-TopLeft    switch ( position ) {        case 1: // Top            rightStart = randomBetween( 0, 50 );            rightEnd = rightStart;            topStart = -50;            topEnd = randomBetween( -30, -15 );            rotate = 'rotate(180deg)';            break;            case 2: // Right            var rotated = randomBetween( 1, 2 );            rightStart = -50;            rightEnd = randomBetween( -30, -15 );;            topStart = randomBetween( 0, 45 );            topEnd = topStart;            if ( rotated == 1 ) { // Rotated                rotate = 'rotate(-45deg)';            } else { // Straight                rotate = 'rotate(-90deg)';            }            break;            case 3: // Bottom            rightStart = randomBetween( 0, 50 );            rightEnd = rightStart;            topStart = 100;            topEnd = randomBetween( 40, 80 );            rotate = 'rotate(0deg)';            break;            case 4: // Left            var rotated = randomBetween( 1, 2 );            rightStart = 100;            topStart = randomBetween( 0, 35 );            topEnd = topStart;            if ( rotated == 1 ) { // Rotated                rightEnd = randomBetween( 70, 80 );                rotate = 'rotate(45deg)';            } else { // Straight                rightEnd = randomBetween( 55, 83 );                rotate = 'rotate(90deg)';            }            break;        case 5: // TopRight            rightStart = -50;            topStart = -50;            rightEnd = randomBetween( -30, -15 );;            topEnd = randomBetween( -30, -15 );            rotate = 'rotate(-135deg)';            break;        case 6: // BottomRight            rightStart = -50;            topStart = 100;            rightEnd = randomBetween( -20, -10 );            topEnd = randomBetween( 60, 80 );            rotate = 'rotate(-45deg)';            break;        case 7: // BottomLeft            rightStart = 100;            rightEnd = randomBetween( 60, 75 );            topStart = 100;            topEnd = randomBetween( 50, 80 );            rotate = 'rotate(45deg)';            break;        case 8: // TopLeft            rightStart = 100;            topStart = -50;            topEnd = randomBetween( -30, -20 );            rightEnd = randomBetween( 65, 75 );            rotate = 'rotate(135deg)';            break;    }//     TweenLite.set( imgBottom, { right: rightEnd+'%', top: topEnd+'%', transform: rotate } );    timeLine        .fromTo( imgBottom, 3, { right: rightStart+'%', top: topStart+'%', transform: rotate }, { ease: Power2.easeOut, right: rightEnd+'%', top: topEnd+'%' } )        .to( imgBottom, 3, { ease: Power2.easeOut, right: rightStart+'%', top: topStart+'%', transform: rotate } );}meanMonkey( );/************************//** * Generates random particles using canvas *  * @class Particles * @constructor */function Particles(){  //particle colors  this.colors = [    '255, 255, 255',    '255, 99, 71',    '19, 19, 19'  ]  //adds gradient to particles on true  this.blurry = true;  //adds white border  this.border = false;  //particle radius min/max  this.minRadius = 10;   this.maxRadius = 35;  //particle opacity min/max  this.minOpacity = .005;  this.maxOpacity = .3;  //particle speed min/max  this.minSpeed = .05;  this.maxSpeed = .5;  //frames per second   this.fps = 60;  //number of particles  this.numParticles = 75;  //required canvas variables  this.canvas = document.getElementById( 'canvas' );  this.ctx = this.canvas.getContext('2d');}/** * Initializes everything * @method init */Particles.prototype.init = function(){  this.render();  this.createCircle();}/** * generates random number between min and max values * @param  {number} min value * @param  {number} max malue * @return {number} random number between min and max * @method _rand */Particles.prototype._rand = function(min, max){  return Math.random() * (max - min) + min;}/** * Sets canvas size and updates values on resize * @method render */Particles.prototype.render = function(){   var self = this,      wHeight = $(window).height(),      wWidth = $(window).width();    self.canvas.width = wWidth;  self.canvas.height = wHeight;    $(window).on('resize', self.render);}/** * Randomly creates particle attributes * @method createCircle */Particles.prototype.createCircle = function(){  var particle = [];  for (var i = 0; i < this.numParticles; i++) {    var self = this,        color = self.colors[~~(self._rand(0, self.colors.length))];        particle[i] = {      radius    : self._rand(self.minRadius, self.maxRadius),      xPos      : self._rand(0, canvas.width),      yPos      : self._rand(0, canvas.height),      xVelocity : self._rand(self.minSpeed, self.maxSpeed),      yVelocity : self._rand(self.minSpeed, self.maxSpeed),      color     : 'rgba(' + color + ',' + self._rand(self.minOpacity, self.maxOpacity) + ')'    }        //once values are determined, draw particle on canvas    self.draw(particle, i);  }  //...and once drawn, animate the particle  self.animate(particle);}/** * Draws particles on canvas * @param  {array} Particle array from createCircle method * @param  {number} i value from createCircle method * @method draw */Particles.prototype.draw = function(particle, i){  var self = this,      ctx = self.ctx;    if (self.blurry === true ) {    //creates gradient if blurry === true    var grd = ctx.createRadialGradient(particle[i].xPos, particle[i].yPos, particle[i].radius, particle[i].xPos, particle[i].yPos, particle[i].radius/1.25);        grd.addColorStop(0.5, particle[i].color);    grd.addColorStop(0.000, 'rgba(34, 34, 34, 0)');    ctx.fillStyle = grd;  } else {    //otherwise sets to solid color w/ opacity value    ctx.fillStyle = particle[i].color;   }    if (self.border === true) {    ctx.strokeStyle = '#fff';    ctx.stroke();  }    ctx.beginPath();  ctx.arc(particle[i].xPos, particle[i].yPos, particle[i].radius, 0, 2 * Math.PI, false);  ctx.fill();}/** * Animates particles  * @param  {array} particle value from createCircle & draw methods * @method animate */Particles.prototype.animate = function(particle){  var self = this,          ctx = self.ctx;    setInterval(function(){    //clears canvas    self.clearCanvas();    //then redraws particles in new positions based on velocity    for (var i = 0; i < self.numParticles; i++) {      particle[i].xPos += particle[i].xVelocity;      particle[i].yPos -= particle[i].yVelocity;           //if particle goes off screen call reset method to place it offscreen to the left/bottom      if (particle[i].xPos > self.canvas.width + particle[i].radius || particle[i].yPos > self.canvas.height + particle[i].radius) {        self.resetParticle(particle, i);      } else {        self.draw(particle, i);      }    }    }, 1000/self.fps); }/** * Resets position of particle when it goes off screen * @param  {array} particle value from createCircle & draw methods * @param  {number} i value from createCircle method * @method resetParticle */Particles.prototype.resetParticle = function(particle, i){  var self = this;    var random = self._rand(0, 1);    if (random > .5) {     // 50% chance particle comes from left side of window...    particle[i].xPos = -particle[i].radius;    particle[i].yPos = self._rand(0, canvas.height);  } else {    //... or bottom of window    particle[i].xPos = self._rand(0, canvas.width);    particle[i].yPos = canvas.height + particle[i].radius;     }  //redraw particle with new values  self.draw(particle, i);}/** * Clears canvas between animation frames * @method clearCanvas */Particles.prototype.clearCanvas = function(){  this.ctx.clearRect(0, 0, canvas.width, canvas.height);} // go go go!var particle = new Particles().init(); } );